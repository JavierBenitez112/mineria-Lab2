# Visualizar los gráficos
print(g1)
print(g2)
ggplot(movies, aes(x = voteAvg, y = revenue)) +
# A. Puntos (Scatter plot)
geom_point(color = "steelblue", alpha = 0.6, size = 3) +
# B. Línea de tendencia (Suavizado o Lineal)
# Usa method = "lm" para una línea recta (regresión lineal)
# Usa method = "loess" para una curva suavizada flexible
geom_smooth(method = "lm", color = "darkred", se = TRUE) +
# C. Etiquetas y tema
labs(
title = "Correlación: Calificaciones vs. Éxito Comercial",
subtitle = "Análisis de impacto de las reseñas en los ingresos",
x = "Calificación (0-10)",
y = "Ingresos Totales ($)",
caption = "Fuente: Datos simulados"
) +
theme_minimal()
peliculas_clean <- peliculas %>%
mutate(
# Transformamos la URL a una categoría simple
# !is.na() verifica que no sea nulo
# homePage != "" verifica que no esté vacío el texto
tiene_web = ifelse(!is.na(homePage) & homePage != "", "Con Página Oficial", "Sin Página Oficial"),
# Transformamos el TRUE/FALSE a texto legible
tiene_video = ifelse(video == TRUE, "Con Video Promo", "Sin Video Promo")
)
peliculas_clean <- movies %>%
mutate(
# Transformamos la URL a una categoría simple
# !is.na() verifica que no sea nulo
# homePage != "" verifica que no esté vacío el texto
tiene_web = ifelse(!is.na(homePage) & homePage != "", "Con Página Oficial", "Sin Página Oficial"),
# Transformamos el TRUE/FALSE a texto legible
tiene_video = ifelse(video == TRUE, "Con Video Promo", "Sin Video Promo")
)
# 3. GRAFICAR (Usando las nuevas variables transformadas)
ggplot(peliculas_clean, aes(x = tiene_web, y = revenue, fill = tiene_video)) +
# Usamos Boxplot
geom_boxplot(alpha = 0.7) +
# Escala logarítmica (Vital para revenue)
scale_y_log10(labels = scales::dollar_format()) +
# Personalización
labs(
title = "Impacto de la Página Web y Video en Ingresos",
subtitle = "¿Vale la pena invertir en sitio web y trailer?",
x = "Presencia de Sitio Web",
y = "Ingresos (Escala Log)",
fill = "Video Promocional"
) +
theme_minimal()
ggplot(movies, aes(x = actorsPopularity, y = revenue)) +
geom_point(aes(color = budget), alpha = 0.7, size = 3) +
geom_smooth(method = "lm", color = "red", se = TRUE) +
scale_y_log10(labels = dollar_format()) +
scale_color_viridis_c(labels = dollar_format(), name = "Presupuesto") +
# D. Etiquetas
labs(
title = "¿Influye la popularidad del elenco en la taquilla?",
subtitle = "Correlación entre actorsPopularity y revenue",
x = "Índice de Popularidad del Elenco (actorsPopularity)",
y = "Ingresos de Taquilla (Escala Log)",
caption = "Nota: El color indica el presupuesto de la película"
) +
theme_minimal()
library(scales)
ggplot(movies, aes(x = actorsPopularity, y = revenue)) +
geom_point(aes(color = budget), alpha = 0.7, size = 3) +
geom_smooth(method = "lm", color = "red", se = TRUE) +
scale_y_log10(labels = dollar_format()) +
scale_color_viridis_c(labels = dollar_format(), name = "Presupuesto") +
# D. Etiquetas
labs(
title = "¿Influye la popularidad del elenco en la taquilla?",
subtitle = "Correlación entre actorsPopularity y revenue",
x = "Índice de Popularidad del Elenco (actorsPopularity)",
y = "Ingresos de Taquilla (Escala Log)",
caption = "Nota: El color indica el presupuesto de la película"
) +
theme_minimal()
with(movies, plot(actorsPopularity,revenue))
with(movies, plot(revenue,actorsPopularity))
knitr::opts_chunk$set(echo = TRUE)
# dependecies
#install.packages("dplyr")
library(ggplot2)
library(dplyr)
library(nortest)
library(scales)
library(lubridate)
movies <- read.csv("Movies_2026.csv")
setwd("~/Documents/GitHub/mineria-Lab2")
knitr::opts_chunk$set(echo = TRUE)
# dependecies
#install.packages("dplyr")
library(ggplot2)
library(dplyr)
library(nortest)
library(scales)
library(lubridate)
movies <- read.csv("Movies_2026.csv")
str(movies)
movies <- subset(movies, select = -id) # we ain't going to summarize the the id for pretty obvious reasons
summary(movies)
cual_nominales <- c(
"genres",
"homePage",
"productionCompany",
"productionCompanyCountry",
"productionCountry",
"video",
"director",
"originalTitle",
"title",
"originalLanguage"
)
cual_ordinales <- c(
"releaseDate"
)
cualitativas <- c(cual_nominales, cual_ordinales)
cualitativas
datos_cual <- movies[, cualitativas]
head(datos_cual, 5)
cuant_discretas <- c(
"budget",
"revenue",
"runtime",
"voteAvg",
"voteCount",
"genresAmount",
"productionCoAmount",
"productionCountriesAmount",
"actorsAmount",
"castWomenAmount",
"castMenAmount",
"releaseYear"
)
cuant_continuas <- c(
"popularity"
)
cuantitativas <- c(cuant_discretas, cuant_continuas)
cuantitativas
datos_cuant <- movies[, cuantitativas]
head(datos_cuant, 5)
lillie_results <- lapply(datos_cuant, lillie.test)
lillie_results
frec <- table(unlist(datos_cual))
par(mar = c(5, 12, 4, 2))
# Ciclo para graficar cada variable cualitativa por separado
for (variable in cualitativas) {
# 1. Crear tabla de frecuencia para la variable actual
tabla <- table(movies[[variable]])
# 2. Ordenar de mayor a menor
tabla <- sort(tabla, decreasing = TRUE)
# 3. Validar si son demasiados datos (ej. Titulos) para mostrar solo el Top 20
if (length(tabla) > 20) {
tabla_graficar <- tabla[1:20]
subtitulo <- "(Top 20 más frecuentes)"
} else {
tabla_graficar <- tabla
subtitulo <- "(Todos los valores)"
}
# 4. Generar el gráfico
# Usamos 'horiz = TRUE' porque es más fácil leer nombres largos de lado
barplot(tabla_graficar,
main = paste("Variable:", variable, subtitulo),
col = "skyblue",
horiz = TRUE,      # Barras horizontales
las = 1,           # Las etiquetas siempre horizontales
cex.names = 0.6    # Tamaño de letra un poco más pequeño
)
}
movies = na.omit(movies )
df_1 <- movies[c('budget', 'title')]
head(df_1[order(df_1$budget, decreasing = TRUE),"title"], n  = 10)
df_2 <- movies[c('revenue', 'title')]
head(df_2[order(movies$revenue, decreasing = TRUE),],n = 10)
df_2 <- movies[c('voteCount', 'title')]
head(df_2[order(movies$voteCount, decreasing = TRUE),], n = 1)
df_2 <- movies[c('voteAvg', 'title')]
head(df_2[order(movies$voteAvg, decreasing = FALSE),], n = 1)
library(dplyr)
year_count <- count(movies,movies$releaseYear)
barplot(year_count$n, names.arg = year_count$`movies$releaseYear`)
head(year_count[order(year_count$n, decreasing = TRUE),],n = 1)
tabla_freq <- function(col) {
as.data.frame(table(col), stringsAsFactors = FALSE) |>
setNames(c("genero", "frecuencia"))
}
genres  <- c("genres")
movies$releaseDate <- as.Date(movies$releaseDate, format = "%Y-%m-%d")
peliculas_recientes <- movies[order(movies$releaseDate, decreasing = TRUE), ][1:20, ]
movies_separated_recientes <- peliculas_recientes |>
tidyr::separate_rows(genres, sep = "\\|")
datos_generos_recientes <- movies_separated_recientes[, genres]
#head(datos_generos_recientes, 5)
lapply(datos_generos_recientes, tabla_freq)
barplot(
table(datos_generos_recientes$genres),
main = "Frecuencia de géneros en las 20 películas más recientes",
xlab = "Género",
ylab = "Frecuencia",
col = "blue"
)
peliculas_runtime <- movies[order(movies$runtime, decreasing = TRUE), ][1:20, ]
movies_separated_runtime <- peliculas_runtime |>
tidyr::separate_rows(genres, sep = "\\|")
datos_generos_runtime <- movies_separated_runtime[, genres]
head(datos_generos_runtime, 5)
lapply(datos_generos_runtime, tabla_freq)
barplot(
table(datos_generos_runtime$genres),
main = "Frecuencia de géneros en las 20 películas más largas",
xlab = "Género",
ylab = "Frecuencia",
col = "blue"
)
movies_genres <- peliculas_runtime |>
tidyr::separate_rows(genres, sep = "\\|")
datos_generos <- movies_genres[, genres]
head(datos_generos, 5)
lapply(datos_generos, tabla_freq)
barplot(
table(datos_generos$genres),
main = "Frecuencia de géneros",
xlab = "Género",
ylab = "Frecuencia",
col = "blue"
)
peliculas_revenue <- movies[order(movies$revenue, decreasing = TRUE), ][1:20, ]
movies_separated_revenue <- peliculas_revenue |>
tidyr::separate_rows(genres, sep = "\\|")
datos_generos_revenue <- movies_separated_revenue[, genres]
head(datos_generos_revenue, 5)
lapply(datos_generos_revenue, tabla_freq)
number_of_actors <- movies |>
tidyr::separate_rows(actors, sep = "\\|") |>
group_by(title) |>
summarise(actorsAmount = n(), .groups = "drop")
#number_of_actors
movies_with_actors <- movies |>
left_join(number_of_actors, by = "title")
head(movies_with_actors,5)
# dispersión de cantidad de actores vs revenue
ggplot(movies_with_actors, aes(x = actorsAmount.y, y = revenue)) +
geom_point(na.rm = TRUE) +
labs(title = "Cantidad de Actores vs Ingresos de las Películas",
x = "Cantidad de Actores",
y = "Revenue") +
scale_x_continuous(labels = comma) +
scale_y_continuous(labels = comma) +
theme_minimal()
# cantidad de actores por año
ggplot(movies_with_actors, aes(x = releaseYear, y = actorsAmount.y)) +
geom_point(na.rm = TRUE) +
labs(title = "Cantidad de Actores por Año",
x = "Año de Lanzamiento",
y = "Cantidad de Actores") +
scale_x_continuous(labels = comma) +
scale_y_continuous(labels = comma) +
theme_minimal()
ggplot(movies_with_actors, aes(x = revenue, y = castMenAmount)) +
geom_point(na.rm = TRUE) +
labs(title = "Cantidad de Actores Hombre por revenue",
x = "Revenue",
y = "Cantidad de Actores Hombre") +
scale_x_continuous(labels = comma) +
scale_y_continuous(labels = comma) +
theme_minimal()
ggplot(movies_with_actors, aes(x = castWomenAmount, y = revenue)) +
geom_point(na.rm = TRUE) +
labs(title = "Cantidad de Actores Mujer por revenue",
x = "Revenue",
y = "Cantidad de Actores Mujer") +
scale_x_continuous(labels = comma) +
scale_y_continuous(labels = comma) +
theme_minimal()
ggplot(movies_with_actors, aes(x = castMenAmount, y = popularity)) +
geom_point(na.rm = TRUE) +
labs(title = "Cantidad de Actores Hombre por popularity",
x = "Cantidad de Actores Hombre",
y = "Popularity") +
scale_x_continuous(labels = comma) +
scale_y_continuous(labels = comma) +
theme_minimal()
ggplot(movies_with_actors, aes(x = castWomenAmount, y = popularity)) +
geom_point(na.rm = TRUE) +
labs(title = "Cantidad de Actores Mujer por popularity",
x = "Cantidad de Actores Mujer",
y = "Popularity") +
scale_x_continuous(labels = comma) +
scale_y_continuous(labels = comma) +
theme_minimal()
top_rated_movies <- movies |>
arrange(desc(voteAvg)) |>
head(20) |>
select(director, title, voteAvg)
top_rated_movies
with(movies, plot(budget,revenue))
movies$releaseDate <- as.Date(movies$releaseDate)
movies$mes <- month(movies$releaseDate, label = TRUE, abbr = TRUE)
df_mensual <- movies %>%
group_by(mes) %>%
summarize(total_revenue = sum(revenue, na.rm = TRUE))
ggplot(df_mensual, aes(x = mes, y = total_revenue, group = 1)) +
geom_area(fill = "steelblue", alpha = 0.3) +
geom_line(color = "steelblue", linewidth = 1) +
geom_point(color = "steelblue", size = 2) +
labs(
title = "Evolución de Ingresos por Mes de Lanzamiento",
subtitle = "Tendencia estacional de ingresos totales",
x = "Mes",
y = "Ingresos Totales (Suma)"
) +
theme_minimal()
movies_clean <- movies %>%
mutate(
date = as.Date(releaseDate),
mes = month(date, label = TRUE, abbr = TRUE),
anio = year(date)
) %>%
filter(!is.na(mes))
conteo_mensual <- movies_clean %>%
group_by(anio, mes) %>%
summarise(n_pelis = n(), revenue_total = sum(revenue, na.rm = TRUE), .groups = "drop")
metricas_finales <- conteo_mensual %>%
group_by(mes) %>%
summarise(
promedio_lanzamientos = mean(n_pelis),
ingresos_totales = sum(revenue_total)
)
g1 <- ggplot(metricas_finales, aes(x = mes, y = ingresos_totales, fill = ingresos_totales)) +
geom_col() +
scale_fill_viridis_c(option = "magma", guide = "none") +
labs(title = "Meses con Mejores Ingresos", y = "Ingresos Totales", x = "") +
theme_minimal()
g2 <- ggplot(metricas_finales, aes(x = mes, y = promedio_lanzamientos)) +
geom_col(fill = "steelblue") +
geom_text(aes(label = round(promedio_lanzamientos, 1)),
vjust = -0.5, size = 3.5) +
labs(
title = "Promedio de Películas Lanzadas por Mes",
subtitle = "¿Cuántas películas se estrenan realmente en un mes típico?",
x = "Mes",
y = "Cant. Promedio de Estrenos"
) +
theme_minimal()
print(g1)
print(g2)
ggplot(movies, aes(x = voteAvg, y = revenue)) +
geom_point(color = "steelblue", alpha = 0.6, size = 3) +
geom_smooth(method = "lm", color = "darkred", se = TRUE) +
labs(
title = "Correlación: Calificaciones vs. Éxito Comercial",
subtitle = "Análisis de impacto de las reseñas en los ingresos",
x = "Calificación (0-10)",
y = "Ingresos Totales ($)",
caption = "Fuente: Datos simulados"
) +
theme_minimal()
peliculas_clean <- movies %>%
mutate(
tiene_web = ifelse(!is.na(homePage) & homePage != "", "Con Página Oficial", "Sin Página Oficial"),
tiene_video = ifelse(video == TRUE, "Con Video Promo", "Sin Video Promo")
)
ggplot(peliculas_clean, aes(x = tiene_web, y = revenue, fill = tiene_video)) +
geom_boxplot(alpha = 0.7) +
scale_y_log10(labels = scales::dollar_format()) +
labs(
title = "Impacto de la Página Web y Video en Ingresos",
subtitle = "¿Vale la pena invertir en sitio web y trailer?",
x = "Presencia de Sitio Web",
y = "Ingresos (Escala Log)",
fill = "Video Promocional"
) +
theme_minimal()
with(movies, plot(revenue,actorsPopularity))
library(cluster)
library(factoextra)
# Seleccionar variables numéricas relevantes para el clustering
# (sin NAs, escaladas para que todas tengan el mismo peso)
vars_cluster <- c("budget", "revenue", "popularity", "voteAvg", "voteCount", "runtime")
movies_cluster <- movies[, vars_cluster]
movies_cluster <- na.omit(movies_cluster)
movies_cluster_scaled <- scale(movies_cluster)
# --- Método del Codo (Elbow Method) ---
# Calcula la suma de cuadrados intra-cluster (WSS) para k = 1 a 10
wss <- sapply(1:10, function(k) {
kmeans(movies_cluster_scaled, centers = k, nstart = 25, iter.max = 100)$tot.withinss
})
# Graficar el codo
plot(1:10, wss,
type = "b",
pch  = 19,
col  = "steelblue",
xlab = "Número de Clusters (k)",
ylab = "WSS (Within-cluster Sum of Squares)",
main = "Método del Codo para determinar k óptimo")
abline(v = which(diff(diff(wss)) == max(diff(diff(wss)))) + 1,
col = "red", lty = 2)
# --- Método de Silueta (Silhouette Method) ---
# Mide qué tan bien encaja cada punto en su cluster vs. clusters vecinos
sil_scores <- sapply(2:10, function(k) {
km  <- kmeans(movies_cluster_scaled, centers = k, nstart = 25, iter.max = 100)
sil <- silhouette(km$cluster, dist(movies_cluster_scaled))
mean(sil[, 3])
})
plot(2:10, sil_scores,
type = "b",
pch  = 19,
col  = "darkorange",
xlab = "Número de Clusters (k)",
ylab = "Promedio del Ancho de Silueta",
main = "Método de Silueta para determinar k óptimo")
abline(v = which.max(sil_scores) + 1, col = "red", lty = 2)
cat("Número óptimo de clusters según silueta:", which.max(sil_scores) + 1, "\n")
# --- Aplicar K-Means con el k óptimo encontrado ---
k_optimo <- which.max(sil_scores) + 1  # ajustar si el codo sugiere otro valor
set.seed(123)
km_final <- kmeans(movies_cluster_scaled, centers = k_optimo, nstart = 25, iter.max = 100)
# Agregar el cluster al dataframe original
movies_cluster$cluster <- as.factor(km_final$cluster)
cat("Distribución de películas por cluster:\n")
print(table(movies_cluster$cluster))
# --- Visualización de Clusters (reducción a 2D con PCA) ---
fviz_cluster(km_final,
data    = movies_cluster_scaled,
palette = "Set2",
geom    = "point",
ellipse.type = "convex",
main    = paste("Clusters de Películas (k =", k_optimo, ")"),
ggtheme = theme_minimal())
# --- Perfil de cada cluster (promedios por grupo) ---
perfil_clusters <- movies_cluster %>%
group_by(cluster) %>%
summarise(across(all_of(vars_cluster), mean, na.rm = TRUE))
print(perfil_clusters)
require(cluster)
require(factoextra)
# --- Preparar los datos (ajusta las variables según tu dataset) ---
vars_cluster <- c("budget", "revenue", "popularity", "voteAvg", "voteCount", "runtime")
d2f <- na.omit(movies[, vars_cluster])
d2f <- as.data.frame(scale(d2f))  # escalar para que PAM funcione correctamente
# --- Método del Codo con PAM ---
wss_pam <- sapply(1:10, function(k) {
pam(d2f, k)$objective["swap"]
})
require(cluster)
require(factoextra)
# --- Preparar los datos (ajusta las variables según tu dataset) ---
vars_cluster <- c("budget", "revenue", "popularity", "voteAvg", "voteCount", "runtime")
d2f <- na.omit(movies[, vars_cluster])
d2f <- as.data.frame(scale(d2f))  # escalar para que PAM funcione correctamente
# --- Método del Codo con PAM ---
wss_pam <- sapply(1:10, function(k) {
pam(d2f, k)$objective["swap"]
})
library(ggplot2)
library(dplyr)
library(nortest)
library(scales)
library(lubridate)
library(cluster)
library(factoextra)
library(dplyr)
library(ggplot2)
require(cluster)
require(factoextra)
require(dplyr)
require(ggplot2)
# Selección de variables numéricas relevantes
vars_cluster <- c("budget", "revenue", "popularity", "voteAvg", "voteCount", "runtime")
d2f_raw <- na.omit(movies[, c("title", vars_cluster)])
d2f <- as.data.frame(scale(d2f_raw[, vars_cluster]))
rownames(d2f) <- d2f_raw$title
d2f_raw <- na.omit(movies[, c("title", vars_cluster)])
d2f_raw <- d2f_raw[!duplicated(d2f_raw$title), ]
d2f <- as.data.frame(scale(d2f_raw[, vars_cluster]))
rownames(d2f) <- d2f_raw$title
cat("Títulos duplicados después de limpieza:", sum(duplicated(rownames(d2f))), "\n")
cat("Filas totales:", nrow(d2f), "\n")
# Selección de variables numéricas relevantes
vars_cluster <- c("budget", "revenue", "popularity", "voteAvg", "voteCount", "runtime")
d2f_raw <- na.omit(movies[, c("title", vars_cluster)])
d2f <- as.data.frame(scale(d2f_raw[, vars_cluster]))
rownames(d2f) <- d2f_raw$title
require(cluster)
require(factoextra)
require(dplyr)
require(ggplot2)
# Selección de variables numéricas relevantes
vars_cluster <- c("budget", "revenue", "popularity", "voteAvg", "voteCount", "runtime")
# Eliminar NAs y duplicados
d2f_raw <- na.omit(movies[, c("title", vars_cluster)])
d2f_raw <- d2f_raw[!duplicated(d2f_raw$title), ]
# Escalar datos
d2f <- as.data.frame(scale(d2f_raw[, vars_cluster]))
rownames(d2f) <- d2f_raw$title
cat("Títulos duplicados:", sum(duplicated(rownames(d2f))), "\n")
cat("Filas totales:", nrow(d2f), "\n")
# Método del Codo: busca el punto donde agregar más clusters ya no reduce
# significativamente la varianza interna (WSS)
fviz_nbclust(d2f, pam, method = "wss") +
geom_vline(xintercept = 3, linetype = "dashed", color = "red") +
labs(
title    = "Método del Codo (WSS) – PAM",
subtitle = "El 'codo' indica el k óptimo donde la reducción de WSS se estabiliza",
x        = "Número de Clusters (k)",
y        = "Suma de cuadrados intra-cluster"
) +
theme_bw()
