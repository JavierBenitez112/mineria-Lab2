---
title: "Lab Analisis Exploratorio"
author: "Pedro Avila, Javier Benitez, Brandon Rivera"
date: "2026-02-07"
output:
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r dependencies}
# dependecies
#install.packages("dplyr")
```

## Librerias

``` {r librarys}
library(ggplot2)
library(dplyr)
library(nortest)
library(scales)
library(lubridate)
library(cluster)
library(factoextra)
library(dplyr)
library(ggplot2)
```

## Inciso 1
- Haga una exploración rápida de sus datos, para eso haga un resumen de su conjunto de datos.

```{r}
movies <- read.csv("Movies_2026.csv")

str(movies)
```

  - Al momento de usar ```str()```, nos podemos hacer una idea de como son los datos en todo el dataset, este analisis se hace luego en el proyecto (en especifico en el inciso 2). Como nos podemos dar cuenta varios de estos campos llegan a tener informacion vacia para su tipo de dato respectivo.
  
```{r}

movies <- subset(movies, select = -id) # we ain't going to summarize the the id for pretty obvious reasons
summary(movies)
```


  - Al resumirlos no podemos agarrar informacion tan relevante para hacer cualquier tipo de analisis ademas de algunos valores numericos en dichos campos. Como ver cantidad de ingresos maximos y medios, prespuesto y ganancia por peliculas. No llega a ser informacion tan valiosa solo viendola de por si, ya que son datos generales entre todas y no de una solo empresa o por el estilo (se puede 'queriear' para lograrlo, pero ese no es el caso).
  
## Inciso 2
  - Diga el tipo de cada una de las variables (cualitativa ordinal o nominal, cuantitativa continua, cuantitativa discreta)

**Cualitativas**
Adicionalmente en estas clasificaciones las variables Actors y ActorsCharacters serian clasificados como cualitativos nominales pero no se agregaron porque es necesario una limpieza de datos antes.

```{r datos cualitativos}
cual_nominales <- c(
  "genres",
  "homePage",
  "productionCompany",
  "productionCompanyCountry",
  "productionCountry",
  "video",
  "director",
  "originalTitle",
  "title",
  "originalLanguage"
)

cual_ordinales <- c(
  "releaseDate"
)

cualitativas <- c(cual_nominales, cual_ordinales)
cualitativas
datos_cual <- movies[, cualitativas]
head(datos_cual, 5)
```

**Cuantitativas**
Adicionalmente en estas clasificaciones la variable ActorsPopularity serian clasificados como cuantitativos continuos pero no se agregaron porque es necesario una limpieza de datos antes.

```{r datos cuantitativos}
cuant_discretas <- c(
  "budget",
  "revenue",
  "runtime",
  "voteAvg",
  "voteCount",
  "genresAmount",
  "productionCoAmount",
  "productionCountriesAmount",
  "actorsAmount",
  "castWomenAmount",
  "castMenAmount",
  "releaseYear"
)

cuant_continuas <- c(
  "popularity"
)

cuantitativas <- c(cuant_discretas, cuant_continuas)
cuantitativas
datos_cuant <- movies[, cuantitativas]
head(datos_cuant, 5)
```

## Inciso 3
  - Investigue si las variables cuantitativas siguen una distribución normal y haga una
tabla de frecuencias de las variables cualitativas. Explique todos los resultados.

```{r inciso3}
lillie_results <- lapply(datos_cuant, lillie.test)
lillie_results

frec <- table(unlist(datos_cual))

par(mar = c(5, 12, 4, 2))

# Ciclo para graficar cada variable cualitativa por separado
for (variable in cualitativas) {
  
  # 1. Crear tabla de frecuencia para la variable actual
  tabla <- table(movies[[variable]])
  
  # 2. Ordenar de mayor a menor
  tabla <- sort(tabla, decreasing = TRUE)
  
  # 3. Validar si son demasiados datos (ej. Titulos) para mostrar solo el Top 20
  if (length(tabla) > 20) {
    tabla_graficar <- tabla[1:20]
    subtitulo <- "(Top 20 más frecuentes)"
  } else {
    tabla_graficar <- tabla
    subtitulo <- "(Todos los valores)"
  }
  
  # 4. Generar el gráfico
  # Usamos 'horiz = TRUE' porque es más fácil leer nombres largos de lado
  barplot(tabla_graficar,
          main = paste("Variable:", variable, subtitulo),
          col = "skyblue",
          horiz = TRUE,      # Barras horizontales
          las = 1,           # Las etiquetas siempre horizontales
          cex.names = 0.6    # Tamaño de letra un poco más pequeño
  )
}
```

## Inciso 4



### 1.  ¿Cuáles son las 10 películas que contaron con más presupuesto?

```{r}

movies = na.omit(movies )

df_1 <- movies[c('budget', 'title')]

head(df_1[order(df_1$budget, decreasing = TRUE),"title"], n  = 10)

```



### 2.  ¿Cuáles son las 10 películas que más ingresos tuvieron?

```{r}

df_2 <- movies[c('revenue', 'title')]

head(df_2[order(movies$revenue, decreasing = TRUE),],n = 10)


```



### 3.  ¿Cuál es la película que más votos tuvo?

```{r}
df_2 <- movies[c('voteCount', 'title')]

head(df_2[order(movies$voteCount, decreasing = TRUE),], n = 1)
  
```



### 4.  ¿Cuál es la peor película de acuerdo a los votos de todos los usuarios?

```{r}

df_2 <- movies[c('voteAvg', 'title')]

head(df_2[order(movies$voteAvg, decreasing = FALSE),], n = 1)
 

```



### 5. ¿Cuántas películas se hicieron en cada año? ¿En qué año se hicieron más películas? Haga un gráfico de barras 

```{r}

library(dplyr)

year_count <- count(movies,movies$releaseYear)

barplot(year_count$n, names.arg = year_count$`movies$releaseYear`)


head(year_count[order(year_count$n, decreasing = TRUE),],n = 1)



```

La grafica esta orenado desde los 30's hasta los 20's, siendo cada barra su a~no especifico, viendo la grafica podemos darnos cuenta como el a~no con mas cantidad de peliculas es el 2025.



### 6. ¿Cuál es el género principal de las 20 películas más recientes? ¿Cuál es el género principal que predomina en el conjunto de datos? Represéntelo usando un gráfico. ¿A qué género principal pertenecen las películas más largas?
```{r genres}
tabla_freq <- function(col) {
  as.data.frame(table(col), stringsAsFactors = FALSE) |>
    setNames(c("genero", "frecuencia"))
}
genres  <- c("genres")

movies$releaseDate <- as.Date(movies$releaseDate, format = "%Y-%m-%d")


peliculas_recientes <- movies[order(movies$releaseDate, decreasing = TRUE), ][1:20, ]
movies_separated_recientes <- peliculas_recientes |>
    tidyr::separate_rows(genres, sep = "\\|")
datos_generos_recientes <- movies_separated_recientes[, genres]
#head(datos_generos_recientes, 5)

lapply(datos_generos_recientes, tabla_freq)
barplot(
    table(datos_generos_recientes$genres),
    main = "Frecuencia de géneros en las 20 películas más recientes",
    xlab = "Género",
    ylab = "Frecuencia",
    col = "blue"
)


peliculas_runtime <- movies[order(movies$runtime, decreasing = TRUE), ][1:20, ]
movies_separated_runtime <- peliculas_runtime |>
    tidyr::separate_rows(genres, sep = "\\|")
datos_generos_runtime <- movies_separated_runtime[, genres]
head(datos_generos_runtime, 5)

lapply(datos_generos_runtime, tabla_freq)
barplot(
    table(datos_generos_runtime$genres),
    main = "Frecuencia de géneros en las 20 películas más largas",
    xlab = "Género",
    ylab = "Frecuencia",
    col = "blue"
)

movies_genres <- peliculas_runtime |>
    tidyr::separate_rows(genres, sep = "\\|")
datos_generos <- movies_genres[, genres]
head(datos_generos, 5)

lapply(datos_generos, tabla_freq)
barplot(
    table(datos_generos$genres),
    main = "Frecuencia de géneros",
    xlab = "Género",
    ylab = "Frecuencia",
    col = "blue"
)
```



### 7. ¿Las películas de qué genero principal obtuvieron mayores ganancias?
```{r revenue}
peliculas_revenue <- movies[order(movies$revenue, decreasing = TRUE), ][1:20, ]
movies_separated_revenue <- peliculas_revenue |>
    tidyr::separate_rows(genres, sep = "\\|")
datos_generos_revenue <- movies_separated_revenue[, genres]
head(datos_generos_revenue, 5) 

lapply(datos_generos_revenue, tabla_freq)
```



### 8. ¿La cantidad de actores influye en los ingresos de las películas?¿se han hecho películas con más actores en los últimos años?
```{r actors revenue}
number_of_actors <- movies |>
  tidyr::separate_rows(actors, sep = "\\|") |>
  group_by(title) |>
  summarise(actorsAmount = n(), .groups = "drop")

#number_of_actors

movies_with_actors <- movies |>
  left_join(number_of_actors, by = "title")

head(movies_with_actors,5)

# dispersión de cantidad de actores vs revenue
ggplot(movies_with_actors, aes(x = actorsAmount.y, y = revenue)) +
  geom_point(na.rm = TRUE) +
  labs(title = "Cantidad de Actores vs Ingresos de las Películas",
       x = "Cantidad de Actores",
       y = "Revenue") +
  scale_x_continuous(labels = comma) +
  scale_y_continuous(labels = comma) +
  theme_minimal()


# cantidad de actores por año
ggplot(movies_with_actors, aes(x = releaseYear, y = actorsAmount.y)) +
  geom_point(na.rm = TRUE) +
  labs(title = "Cantidad de Actores por Año",
       x = "Año de Lanzamiento",
       y = "Cantidad de Actores") +
  scale_x_continuous(labels = comma) +
  scale_y_continuous(labels = comma) +
  theme_minimal()
```

Estas graficas no siguen una forma de relacion lineal, al mismo tiempo no cuenta con subidas ni bajas entonces se podria concluir que no hay relacion entre cantidad de catores contra ingresos o cantidad de actores contra años



### 9. ¿Es posible que la cantidad de hombres y mujeres en el reparto influya en la popularidad y los ingresos de las películas?
``` {r hombres vs mujeres}
ggplot(movies_with_actors, aes(x = revenue, y = castMenAmount)) +
  geom_point(na.rm = TRUE) +
  labs(title = "Cantidad de Actores Hombre por revenue",
       x = "Revenue",
       y = "Cantidad de Actores Hombre") +
  scale_x_continuous(labels = comma) +
  scale_y_continuous(labels = comma) +
  theme_minimal()

ggplot(movies_with_actors, aes(x = castWomenAmount, y = revenue)) +
  geom_point(na.rm = TRUE) +
  labs(title = "Cantidad de Actores Mujer por revenue",
       x = "Revenue",
       y = "Cantidad de Actores Mujer") +
  scale_x_continuous(labels = comma) +
  scale_y_continuous(labels = comma) +
  theme_minimal()

  ggplot(movies_with_actors, aes(x = castMenAmount, y = popularity)) +
  geom_point(na.rm = TRUE) +
  labs(title = "Cantidad de Actores Hombre por popularity",
       x = "Cantidad de Actores Hombre",
       y = "Popularity") +
  scale_x_continuous(labels = comma) +
  scale_y_continuous(labels = comma) +
  theme_minimal()

ggplot(movies_with_actors, aes(x = castWomenAmount, y = popularity)) +
  geom_point(na.rm = TRUE) +
  labs(title = "Cantidad de Actores Mujer por popularity",
       x = "Cantidad de Actores Mujer",
       y = "Popularity") +
  scale_x_continuous(labels = comma) +
  scale_y_continuous(labels = comma) +
  theme_minimal()
```

De la misma forma que el inciso anterior ninguna de las graficas sigue una forma de relacion lineal entonces se podria asumir que no hay relacion, por otro lado esto tambien puede ser por data incompleta o mal formateada.



### 10. ¿Quiénes son los directores que hicieron las 20 películas mejor calificadas?
```{r best rated directors}
top_rated_movies <- movies |>
  arrange(desc(voteAvg)) |>
  head(20) |>
  select(director, title, voteAvg)

top_rated_movies
```



### 11.¿Cómo se correlacionan los presupuestos con los ingresos? ¿Los altos presupuestos significan altos ingresos?

En este caso como se puede observar en la grafica hay muchos datos irregulares que no siguen ninguna tendecia evidente por lo que se puede decir que entre estos 2 datos los presupuestos e ingresos no estan relacionados directamente

```{r}
with(movies, plot(budget,revenue))
```



### 12. ¿Se asocian ciertos meses de lanzamiento con mejores ingresos?

Si como se puede observar en la grafica si hay ciertos meses en los que hay lanzamientos que obtienen mas ingresos a diferencia de los otros meses entonces los mejores meses para lanzar una pelicula es en Julio y en Diciembre


```{r}
movies$releaseDate <- as.Date(movies$releaseDate)
movies$mes <- month(movies$releaseDate, label = TRUE, abbr = TRUE)

df_mensual <- movies %>%
  group_by(mes) %>%
  summarize(total_revenue = sum(revenue, na.rm = TRUE))

ggplot(df_mensual, aes(x = mes, y = total_revenue, group = 1)) +
  geom_area(fill = "steelblue", alpha = 0.3) + 
  geom_line(color = "steelblue", linewidth = 1) + 
  geom_point(color = "steelblue", size = 2) +
  labs(
    title = "Evolución de Ingresos por Mes de Lanzamiento",
    subtitle = "Tendencia estacional de ingresos totales",
    x = "Mes",
    y = "Ingresos Totales (Suma)"
  ) +
  theme_minimal()
```



### 13. ¿En qué meses se han visto los lanzamientos con mejores ingresos?¿cuantas películas, en promedio, se han lanzado por mes?

Junio es el mes con mejores ingresos y en promedio se lanzan 25.23 peliculas por mes.

```{r}

movies_clean <- movies %>%
  mutate(
    date = as.Date(releaseDate),
    mes = month(date, label = TRUE, abbr = TRUE),
    anio = year(date)
  ) %>%
  filter(!is.na(mes))

conteo_mensual <- movies_clean %>%
  group_by(anio, mes) %>%
  summarise(n_pelis = n(), revenue_total = sum(revenue, na.rm = TRUE), .groups = "drop")

metricas_finales <- conteo_mensual %>%
  group_by(mes) %>%
  summarise(
    promedio_lanzamientos = mean(n_pelis),
    ingresos_totales = sum(revenue_total)
  )

g1 <- ggplot(metricas_finales, aes(x = mes, y = ingresos_totales, fill = ingresos_totales)) +
  geom_col() +
  scale_fill_viridis_c(option = "magma", guide = "none") +
  labs(title = "Meses con Mejores Ingresos", y = "Ingresos Totales", x = "") +
  theme_minimal()

g2 <- ggplot(metricas_finales, aes(x = mes, y = promedio_lanzamientos)) +
  geom_col(fill = "steelblue") +
  geom_text(aes(label = round(promedio_lanzamientos, 1)), 
            vjust = -0.5, size = 3.5) +
  labs(
    title = "Promedio de Películas Lanzadas por Mes",
    subtitle = "¿Cuántas películas se estrenan realmente en un mes típico?",
    x = "Mes",
    y = "Cant. Promedio de Estrenos"
  ) +
  theme_minimal()

print(g1)
print(g2)
```



### 14. ¿Cómo se correlacionan las calificaciones con el éxito comercial?

Las peliculas entre los 7.5 de calificacion son las peliculas que mas ingresos tienen pero hay muchas peliculas que son un 10 total pero que no generaron apenas ingresos y de igual manera peliculas con una puntuacion de 7.5 podrian no haber generado ningun ingreso no es garantizado un gran ingreso pero si es mas probable

```{r}
ggplot(movies, aes(x = voteAvg, y = revenue)) +
  geom_point(color = "steelblue", alpha = 0.6, size = 3) +
  
  geom_smooth(method = "lm", color = "darkred", se = TRUE) +
  
  labs(
    title = "Correlación: Calificaciones vs. Éxito Comercial",
    subtitle = "Análisis de impacto de las reseñas en los ingresos",
    x = "Calificación (0-10)",
    y = "Ingresos Totales ($)",
    caption = "Fuente: Datos simulados"
  ) +
  theme_minimal()
```



### 15. ¿Qué estrategias de marketing, como videos promocionales o páginas oficiales, generan mejores resultados?

Las peliculas con pagina oficial tienen mas revenue por ende el sitio web es mejor estrategia

```{r}
peliculas_clean <- movies %>%
  mutate(
    tiene_web = ifelse(!is.na(homePage) & homePage != "", "Con Página Oficial", "Sin Página Oficial"),

    tiene_video = ifelse(video == TRUE, "Con Video Promo", "Sin Video Promo")
  )

ggplot(peliculas_clean, aes(x = tiene_web, y = revenue, fill = tiene_video)) +
  
  geom_boxplot(alpha = 0.7) +
  
  scale_y_log10(labels = scales::dollar_format()) +
  
  labs(
    title = "Impacto de la Página Web y Video en Ingresos",
    subtitle = "¿Vale la pena invertir en sitio web y trailer?",
    x = "Presencia de Sitio Web",
    y = "Ingresos (Escala Log)",
    fill = "Video Promocional"
  ) +
  theme_minimal()
```



### 16. ¿La popularidad del elenco está directamente correlacionada con el éxito de taquilla?

```{r}
  with(movies, plot(revenue,actorsPopularity))
```

No como se puede ver en esta grafica no esta directamente relacionada la popularidad de un actor con el ingreso de la pelicula


## Análisis de Clustering

### Preparación de datos
```{r cluster_prep}
require(cluster)
require(factoextra)
require(dplyr)
require(ggplot2)

# Selección de variables numéricas relevantes
vars_cluster <- c("budget", "revenue", "popularity", "voteAvg", "voteCount", "runtime")

# Eliminar NAs y duplicados
d2f_raw <- na.omit(movies[, c("title", vars_cluster)])
d2f_raw <- d2f_raw[!duplicated(d2f_raw$title), ]

# Escalar datos
d2f <- as.data.frame(scale(d2f_raw[, vars_cluster]))
rownames(d2f) <- d2f_raw$title

cat("Títulos duplicados:", sum(duplicated(rownames(d2f))), "\n")
cat("Filas totales:", nrow(d2f), "\n")
```

---

### Parte 1 – Determinación del número óptimo de clusters
```{r optimal_k_elbow}
# Método del Codo: busca el punto donde agregar más clusters ya no reduce 
# significativamente la varianza interna (WSS)
fviz_nbclust(d2f, pam, method = "wss") +
  geom_vline(xintercept = 3, linetype = "dashed", color = "red") +
  labs(
    title    = "Método del Codo (WSS) – PAM",
    subtitle = "El 'codo' indica el k óptimo donde la reducción de WSS se estabiliza",
    x        = "Número de Clusters (k)",
    y        = "Suma de cuadrados intra-cluster"
  ) +
  theme_bw()
```


```{r optimal_k_silhouette}
# Método de Silueta: mide qué tan bien separados están los clusters
# Un valor cercano a 1 = clusters bien definidos; cercano a 0 = solapados
fviz_nbclust(d2f, pam, method = "silhouette") +
  labs(
    title    = "Método de Silueta – PAM",
    subtitle = "El k con mayor ancho de silueta promedio es el óptimo",
    x        = "Número de Clusters (k)",
    y        = "Ancho de Silueta Promedio"
  ) +
  theme_bw()
```
```{r optimal_k_gap}
# Método Gap Statistic: compara la dispersión interna observada contra 
# una distribución de referencia aleatoria
set.seed(123)
gap_stat <- clusGap(d2f, FUN = pam, K.max = 10, B = 50)

fviz_gap_stat(gap_stat) +
  labs(
    title    = "Gap Statistic – PAM",
    subtitle = "El k óptimo es donde Gap(k) es máximo o donde se estabiliza",
    x        = "Número de Clusters (k)",
    y        = "Gap Statistic"
  ) +
  theme_bw()

k_optimo_gap <- which.max(gap_stat$Tab[, "gap"])
cat("K óptimo según Gap Statistic:", k_optimo_gap, "\n")
```
```{r silhouette_scores_table}
# Tabla comparativa de ancho de silueta por k
sil_scores <- sapply(2:8, function(k) {
  round(mean(pam(d2f, k)$silinfo$avg.width), 4)
})

sil_tabla <- data.frame(
  k              = 2:8,
  Silhouette     = sil_scores,
  Interpretacion = ifelse(sil_scores >= 0.70, "Estructura fuerte",
                   ifelse(sil_scores >= 0.50, "Estructura razonable",
                   ifelse(sil_scores >= 0.25, "Estructura débil", "Sin estructura")))
)

print(sil_tabla)

k_final <- sil_tabla$k[which.max(sil_tabla$Silhouette)]
cat("\nK seleccionado para el análisis:", k_final, "\n")
cat("Ancho de silueta promedio:", max(sil_tabla$Silhouette), "\n")
```

---

### Parte 2 – Agrupamiento con múltiples algoritmos y comparación
```{r kmeans_clustering}
# Algoritmo 1: K-Means
set.seed(123)
km_res <- kmeans(d2f, centers = k_final, nstart = 25, iter.max = 100)

p_kmeans <- fviz_cluster(km_res, data = d2f,
               geom         = "point",
               ellipse.type = "norm",
               palette      = "Set2",
               alpha        = 0.6) +
  labs(
    title    = "K-Means",
    subtitle = paste("k =", k_final)
  ) +
  theme_bw()

print(p_kmeans)
```
```{r pam_clustering}
# Algoritmo 2: PAM (K-Medoids) – más robusto a outliers que K-Means
pam.res <- pam(d2f, k_final)

p_pam <- fviz_cluster(pam.res,
               geom             = "point",
               ellipse.type     = "norm",
               show.clust.cent  = TRUE,
               star.plot        = TRUE,
               palette          = "Set2") +
  labs(
    title    = "PAM (K-Medoids)",
    subtitle = paste("k =", k_final)
  ) +
  theme_bw()

print(p_pam)
```
```{r hierarchical_clustering}
# Algoritmo 3: Clustering Jerárquico (Ward)
dist_matrix <- dist(d2f, method = "euclidean")
hc_res      <- hclust(dist_matrix, method = "ward.D2")

# Dendrograma
plot(hc_res, labels = FALSE, hang = -1,
     main = "Dendrograma – Clustering Jerárquico (Ward)",
     xlab = "Películas",
     ylab = "Distancia")
rect.hclust(hc_res, k = k_final, border = 2:(k_final + 1))

hc_clusters <- cutree(hc_res, k = k_final)
```
```{r quality_comparison}
# Comparación de calidad mediante Silueta
sil_km  <- silhouette(km_res$cluster,  dist(d2f))
sil_pam <- silhouette(pam.res$cluster, dist(d2f))
sil_hc  <- silhouette(hc_clusters,     dist(d2f))

calidad <- data.frame(
  Algoritmo           = c("K-Means", "PAM (K-Medoids)", "Jerárquico (Ward)"),
  Silhouette_Promedio = round(c(
    mean(sil_km[, 3]),
    mean(sil_pam[, 3]),
    mean(sil_hc[, 3])
  ), 4),
  Clusters = k_final
)

print(calidad)

# Gráficos de silueta individuales
par(mfrow = c(1, 3))
plot(sil_km,  main = "Silueta K-Means",    col = 2:(k_final + 1), border = NA)
plot(sil_pam, main = "Silueta PAM",        col = 2:(k_final + 1), border = NA)
plot(sil_hc,  main = "Silueta Jerárquico", col = 2:(k_final + 1), border = NA)
par(mfrow = c(1, 1))

# Algoritmo ganador
mejor_algoritmo <- calidad$Algoritmo[which.max(calidad$Silhouette_Promedio)]
cat("\nAlgoritmo con mejor calidad de clusters:", mejor_algoritmo, "\n")
```

---

### Parte 3 – Interpretación de los grupos
```{r cluster_assignment}
# Asignar cluster PAM al dataframe original (sin escalar)
d2f_raw$cluster <- as.factor(pam.res$cluster)
```
```{r cluster_medidas_tendencia}
# Medidas de tendencia central por cluster
perfil <- d2f_raw %>%
  group_by(cluster) %>%
  summarise(
    n_peliculas    = n(),
    budget_media   = round(mean(budget,     na.rm = TRUE), 0),
    budget_mediana = round(median(budget,   na.rm = TRUE), 0),
    revenue_media  = round(mean(revenue,    na.rm = TRUE), 0),
    revenue_mediana= round(median(revenue,  na.rm = TRUE), 0),
    pop_media      = round(mean(popularity, na.rm = TRUE), 2),
    voteAvg_media  = round(mean(voteAvg,    na.rm = TRUE), 2),
    voteCount_media= round(mean(voteCount,  na.rm = TRUE), 0),
    runtime_media  = round(mean(runtime,    na.rm = TRUE), 1)
  )

print(perfil)
```
```{r cluster_boxplots}
# Boxplots comparativos por cluster para cada variable
for (v in vars_cluster) {
  p <- ggplot(d2f_raw, aes_string(x = "cluster", y = v, fill = "cluster")) +
    geom_boxplot(alpha = 0.7, outlier.color = "red", outlier.size = 1) +
    scale_fill_brewer(palette = "Set2") +
    labs(
      title    = paste("Distribución de", v, "por Cluster"),
      subtitle = "Los outliers en rojo representan películas atípicas dentro del grupo",
      x        = "Cluster",
      y        = v
    ) +
    theme_bw() +
    theme(legend.position = "none")
  print(p)
}
```
```{r cluster_freq_genres}
# Tabla de frecuencia de géneros por cluster
movies_con_cluster <- movies %>%
  filter(title %in% d2f_raw$title) %>%
  left_join(d2f_raw[, c("title", "cluster")], by = "title") %>%
  tidyr::separate_rows(genres, sep = "\\|")

tabla_generos <- movies_con_cluster %>%
  group_by(cluster, genres) %>%
  summarise(frecuencia = n(), .groups = "drop") %>%
  arrange(cluster, desc(frecuencia))

# Top 5 géneros por cluster
top_generos <- tabla_generos %>%
  group_by(cluster) %>%
  slice_max(frecuencia, n = 5)

print(top_generos)

# Gráfico de géneros por cluster
ggplot(top_generos, aes(x = reorder(genres, frecuencia), y = frecuencia, fill = cluster)) +
  geom_col(show.legend = FALSE) +
  facet_wrap(~cluster, scales = "free_y") +
  coord_flip() +
  scale_fill_brewer(palette = "Set2") +
  labs(
    title    = "Top 5 Géneros por Cluster",
    subtitle = "Distribución de géneros dentro de cada grupo de películas",
    x        = "Género",
    y        = "Frecuencia"
  ) +
  theme_bw()
```
```{r cluster_top_movies}
# Películas medoides: las más representativas de cada cluster
medoides_idx      <- pam.res$id.med
peliculas_medoides <- d2f_raw[medoides_idx, c("title", "cluster", vars_cluster)]

cat("=== Películas Medoides (más representativas de cada cluster) ===\n")
print(peliculas_medoides)
```
```{r cluster_perfil_comparativo}
# Perfil normalizado para comparación visual entre clusters
perfil_norm <- perfil %>%
  select(cluster, budget_media, revenue_media, pop_media, voteAvg_media, runtime_media) %>%
  mutate(across(-cluster, ~ round((. - min(.)) / (max(.) - min(.)), 4)))

cat("=== Perfil normalizado de clusters (0 = mínimo, 1 = máximo) ===\n")
print(perfil_norm)

# Gráfico comparativo de perfiles
perfil_long <- perfil_norm %>%
  tidyr::pivot_longer(-cluster, names_to = "variable", values_to = "valor")

ggplot(perfil_long, aes(x = variable, y = valor, fill = cluster)) +
  geom_col(position = "dodge", alpha = 0.8) +
  scale_fill_brewer(palette = "Set2") +
  labs(
    title    = "Perfil Comparativo de Clusters (valores normalizados)",
    subtitle = "Permite identificar en qué dimensiones se diferencia cada grupo",
    x        = "Variable",
    y        = "Valor Normalizado (0–1)",
    fill     = "Cluster"
  ) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 30, hjust = 1))
```
```{r cluster_scatter_revenue_budget}
# Dispersión revenue vs budget coloreado por cluster
ggplot(d2f_raw, aes(x = budget, y = revenue, color = cluster)) +
  geom_point(alpha = 0.6, size = 2) +
  scale_color_brewer(palette = "Set2") +
  scale_x_continuous(labels = scales::comma) +
  scale_y_continuous(labels = scales::comma) +
  labs(
    title    = "Budget vs Revenue por Cluster",
    subtitle = "Cada color representa un grupo de películas con características similares",
    x        = "Presupuesto (Budget)",
    y        = "Ingresos (Revenue)",
    color    = "Cluster"
  ) +
  theme_bw()
```
```{r cluster_scatter_popularity_vote}
# Dispersión popularity vs voteAvg coloreado por cluster
ggplot(d2f_raw, aes(x = popularity, y = voteAvg, color = cluster)) +
  geom_point(alpha = 0.6, size = 2) +
  scale_color_brewer(palette = "Set2") +
  labs(
    title    = "Popularidad vs Calificación Promedio por Cluster",
    subtitle = "¿Los clusters más populares también son los mejor calificados?",
    x        = "Popularidad",
    y        = "Calificación Promedio (voteAvg)",
    color    = "Cluster"
  ) +
  theme_bw()
```

